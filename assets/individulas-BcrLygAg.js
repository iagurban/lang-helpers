var ue=Object.defineProperty;var ae=(e,r,t)=>r in e?ue(e,r,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[r]=t;var m=(e,r,t)=>ae(e,typeof r!="symbol"?r+"":r,t);import{m as ce,a as x,o as le,r as R}from"./vendor-CDI-7JtX.js";class fe extends Error{constructor(r){super("Programming error"+(r?`: ${r}`:""))}}const de=(e,r)=>{if(!e)throw new fe(r?.())};class y{constructor(r){m(this,"_m");this._m=new Map(r)}clear(){this._m.clear()}delete(r){return this._m.delete(r)}forEach(r){for(const[t,n]of this._m)r(n,t,this)}get(r){return this._m.get(r)}has(r){return this._m.has(r)}set(r,t){return this._m.set(r,t),this}get size(){return this._m.size}static groupedBy(r,t){const n=new y;for(const s of r)n.update(t(s),o=>o?(o.push(s),o):[s]);return n}static mappedBy(r,t){const n=new y;for(const s of r)n.set(t(s),s);return n}getOrCreate(r,t,n){let s=this.get(r);return s==null?this.set(r,s=t(r)):n&&n(s,r),s}update(r,t){return this.set(r,t(this.get(r),r))}mapEntries(r){return new y([...this.entries()].map(([t,n])=>[t,r(n,t)]))}toArray(r){return[...this.entries()].map(([t,n])=>r(n,t))}valuesToArray(r){return[...this.values()].map(t=>r(t))}deleteKeys(r){for(const t of r)this.delete(t);return this}assign(r){for(const[t,n]of r)this.set(t,n);return this}backup(r){const t=r?r(this):new y(this);return()=>{this.clear(),this.assign(t)}}filter(r){return new y([...this.entries()].filter(([t,n])=>r(n,t)))}freeze(){const r={value(){throw new Error("Can not mutate frozen ExMap")},configurable:!1,enumerable:!1};for(const t of["set","delete","clear"])Object.defineProperty(this,t,r);return Object.freeze(this),this}[Symbol.iterator](){return this._m[Symbol.iterator]()}entries(){return this._m.entries()}keys(){return this._m.keys()}values(){return this._m.values()}get[Symbol.toStringTag](){return"ExMap"}}const h=(e,r)=>Object.assign(e,{type:r}),C=Symbol("gettrTag:cachedTypeSymbol"),q=(e,r,t=!0)=>(Object.defineProperty(e,"type",{get:t?()=>e[C]??(e[C]=r()):r,set:void 0,enumerable:!0,configurable:!0}),e),J=e=>e.type??"[unknown]",he=(e,r=[])=>{const t=r.filter(n=>n!=null&&n!==!1);return t.length===0?e:`${e}(${t.join(", ")})`};h(e=>e!=null,"[defined]");h(e=>e!==void 0,"!undefined");h(e=>e!==null,"!null");const wr=h(e=>!!e,"[truthy]"),zr=h(e=>e===void 0,"undefined");h(e=>e===null,"null");h(e=>e==null,"(null|undefined)");h(e=>typeof e=="symbol","symbol");h(e=>e instanceof Error,"error");h(e=>e instanceof RegExp,"regexp");h(e=>e instanceof Map,"map");h(e=>e instanceof Set,"set");const pe=h(e=>Array.isArray(e),"readonly-array");function $r(e,r,t){if(!r(e)){const n=t(e);throw typeof n=="string"?new Error(n):n}return e}const me=(e,r)=>t=>e(t)&&r(t),ge=e=>({push(r){this.run=me(this.run,r)},run:e}),Pr=(e={})=>{const r=(()=>{const n=ge(u=>!0),{minLength:s,maxLength:o,check:i}=e;return s!=null&&n.push(u=>u.length>=s),o!=null&&n.push(u=>u.length<=o),i!=null&&n.push(i),n.run})(),{item:t}=e;return q(n=>{if(!Array.isArray(n)||!r(n))return!1;if(t==null)return!0;for(const s of n)if(!t(s))return!1;return!0},()=>he(`${t?J(t):"unknown"}[]`,[e.minLength!=null&&`len>=${e.minLength}`,e.maxLength!=null&&`len<=${e.maxLength}`,e.check&&(e.checkName??"custom")]))},Sr=h(e=>typeof e=="boolean","boolean"),kr=h(e=>typeof e=="object"&&e!=null&&!Array.isArray(e),"some-object"),jr=(...e)=>q(r=>{for(const t of e)if(t(r))return!0;return!1},()=>`(${e.map(r=>J(r)).join(" | ")})`),Ar=h(e=>typeof e=="string","string");class U extends Error{}const be=(e,r="arg is null")=>{if(e==null){if(typeof r=="string")throw new U(r);const t=r();throw typeof t=="string"?new U(t):t}return e},Er=(e,r)=>Array.from({length:e},(t,n)=>r(n)),D=(e,r,t)=>(Object.defineProperty(e,r,{value:t,writable:!1,enumerable:!0,configurable:!0}),t);function z(e,r,t,n){if(t===!0)return D(e,r,n);const{get:s,set:o}=t;if(!s||o)throw new Error("decorator must be called on getters only");return{get(){return D(this,r,s.call(this))},enumerable:!0,configurable:!0}}const _e=globalThis.crypto?.getRandomValues?(()=>{const e=r=>{const t=new Uint8Array(r);return globalThis.crypto.getRandomValues(t),t};return Object.assign(e,{hex:r=>Array.from(e(r)).map(t=>t.toString(16).padStart(2,"0")).join("")})})():(e=>Object.assign(r=>e.randomBytes(r),{hex:r=>e.randomBytes(r).toString("hex")}))(typeof require=="function"?require("crypto"):{randomBytes:Object.assign(()=>{throw new Error("Secure random generation not supported")},{hex:()=>{throw new Error("Secure random generation not supported")}})});function Z(e,r,t,n){var s=arguments.length,o=s<3?r:n===null?n=Object.getOwnPropertyDescriptor(r,t):n,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(e,r,t,n);else for(var u=e.length-1;u>=0;u--)(i=e[u])&&(o=(s<3?i(o):s>3?i(r,t,o):i(r,t))||o);return s>3&&o&&Object.defineProperty(r,t,o),o}class ye{constructor(r,t=20){m(this,"base");m(this,"powers",[1n]);if(this.base=r,r<2n)throw new Error("mapping length must be > 1");this.get(Math.max(1,t)-1)}get(r){let t=this.powers.length-1;for(;r>t++;)this.powers.push(this.base*this.powers[this.powers.length-1]);return this.powers[r]}}class ${constructor(r){m(this,"parts");m(this,"from10",r=>{if(typeof r=="number"&&Math.floor(r)!==r)throw new Error(`n is floating ${r}`);let t=BigInt(r);if(t<0n)throw new Error(`n is negative: ${t}`);const{base:n,digits:s}=this;if(n===10n)throw new Error("mapping length must be != 10");const o=[];do o.push(s[Number(t%n)]),t/=n;while(t>0n);return String.fromCharCode(...o.reverse())});m(this,"to10",r=>{const{byChar:t,powers:n}=this;let s=0n;for(let o=r.length-1;o>=0;--o){const i=t.get(r.charCodeAt(o));if(i===void 0)throw new Error(`invalid char '${r[o]}' in '${r}'`);s+=i*n.get(r.length-1-o)}return s});m(this,"mask",r=>{const t=this.digits[this.digits.length-1];return String.fromCharCode(...Array.from({length:r},()=>t))});m(this,"random",r=>{if(r<1||Math.floor(r)!==r)throw new Error(`random length must be integer > 0, got ${r}`);return String.fromCharCode(...Array.from({length:r},()=>this.digits[Math.random()*this.digits.length|0]))});m(this,"fixedWidthRandomGenerator",r=>{const t=l=>{const f=Number(this.to10(this.mask(l)));if(f<=0||!Number.isFinite(f))throw new Error(`invalid mask: ${f}`);const p=BigInt(f),k=Math.ceil(Math.log2(f)),w=Math.max(1,Math.ceil(k/8)),L=1n<<BigInt(8*w),oe=L-L%p;return()=>{for(;;){const ie=_e(w);let O=0n;for(let T=0;T<w;T++)O=O<<8n|BigInt(ie[T]);if(O<oe)return Number(O%p)}}};if(r<1||Math.floor(r)!==r)throw new Error(`length must be integer < 1, got ${r}`);const n=String.fromCharCode(this.digits[0]),s=this.maxSafeExponent,o=r%s,i=Math.floor(r/s),u=(l,f)=>this.from10(l()).padStart(f,n),c=l=>{const f=[];for(let p=0;p<i;++p)f.push(u(l,s));return f.join("")};if(o>0){const l=t(o);if(i>0){const f=t(s);return()=>c(f)+u(l,o)}return()=>u(l,r)}de(i>0);const a=t(s);return()=>c(a)});this.parts=r}get base(){return BigInt(this.digits.length)}get digits(){return[...this.digitsSet].sort((t,n)=>t-n)}get digitsSet(){const r=new Set;for(const[t,n]of this.parts.entries())if(pe(n)){if(n.length!==2||n[0].length!==1||n[1].length!==1)throw new Error(`parts[${t}] must be ['a','z'] (to add a range) or 'abc0xyz' (to add by char)`);const[s,o]=Array.from(n).map(i=>i.codePointAt(0));if(s>o)throw new Error(`parts[${t}] 'from' must be <= 'to', got '${s}' > '${o}'`);for(let i=0;i<o-s+1;++i)r.add(s+i)}else for(let s=0;s<n.length;++s)r.add(n.codePointAt(s));if(r.size<2)throw new Error("empty digits set");return r}get powers(){return new ye(this.base)}get byChar(){return new Map([...this.digits].map((r,t)=>[r,BigInt(t)]))}get maxSafeInteger(){return this.from10(BigInt(Number.MAX_SAFE_INTEGER))}get maxSafeExponent(){return this.maxSafeInteger.length-1}}Z([z],$.prototype,"digits",null);Z([z],$.prototype,"digitsSet",null);Z([z],$.prototype,"powers",null);Z([z],$.prototype,"byChar",null);Z([z],$.prototype,"maxSafeInteger",null);const ve=e=>{const r={};for(const[t,n]of Object.entries(e))r[t]=r[`b${t}`]=new $(n);return r},we={...ve({2:[["0","1"]],3:[["0","2"]],4:[["0","3"]],6:[["0","5"]],8:[["0","7"]],10:[["0","9"]],16:[["0","9"],["a","f"]],62:[["0","9"],["a","z"],["A","Z"]],70:[["0","9"],["a","z"],["A","Z"],"!@$&%+_="],88:[["0","9"],["a","z"],["A","Z"],`_+-=~!?@#:*&^%$.,{}[]<>'"/`]})},{b62:{from10:ze,to10:$e,mask:Pe,fixedWidthRandomGenerator:X}}=we,Se=X(16);X(12);const H=e=>{const r=Number($e(Pe(e)));return()=>ze(Date.now()%r).padStart(e,"0")},ke=H(4);H(2);const Zr=()=>`${ke()}${Se()}`;class Or extends y{constructor(r){super(r),ce(this,{_m:le,set:x,delete:x,clear:x})}}const Mr=e=>{const r=R.createContext(void 0),t=()=>R.useContext(r);return{ctx:r,use:()=>be(t(),()=>`"${e}" is not provided`),useIfProvided:t,provider:r.Provider}};function je(e,r,t,n){var s=arguments.length,o=s<3?r:n===null?n=Object.getOwnPropertyDescriptor(r,t):n,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(e,r,t,n);else for(var u=e.length-1;u>=0;u--)(i=e[u])&&(o=(s<3?i(o):s>3?i(r,t,o):i(r,t))||o);return s>3&&o&&Object.defineProperty(r,t,o),o}class Q{constructor(){m(this,"callback",null);m(this,"ref",{observer:()=>this.observer,_current:null,get current(){return this._current},set current(r){this._current!==r&&(this._current&&this.observer().unobserve(this._current),this._current=r,r&&this.observer().observe(r))}})}setCallback(r){this.callback=r}get observer(){return new ResizeObserver(r=>this.observed(r))}observed(r){if(!this.callback)return;const t=r.find(n=>n.target===this.ref.current);t&&this.callback(t)}destroy(){this.ref.current=null}}je([z],Q.prototype,"observer",null);const Rr=e=>{const r=R.useRef(void 0);return r.current||(r.current=new Q),r.current.callback=e,R.useEffect(()=>()=>{r.current&&(r.current.destroy(),r.current=void 0)},[]),r.current};function d(e,r,t){function n(u,c){if(u._zod||Object.defineProperty(u,"_zod",{value:{def:c,constr:i,traits:new Set},enumerable:!1}),u._zod.traits.has(e))return;u._zod.traits.add(e),r(u,c);const a=i.prototype,l=Object.keys(a);for(let f=0;f<l.length;f++){const p=l[f];p in u||(u[p]=a[p].bind(u))}}const s=t?.Parent??Object;class o extends s{}Object.defineProperty(o,"name",{value:e});function i(u){var c;const a=t?.Parent?new o:this;n(a,u),(c=a._zod).deferred??(c.deferred=[]);for(const l of a._zod.deferred)l();return a}return Object.defineProperty(i,"init",{value:n}),Object.defineProperty(i,Symbol.hasInstance,{value:u=>t?.Parent&&u instanceof t.Parent?!0:u?._zod?.traits?.has(e)}),Object.defineProperty(i,"name",{value:e}),i}class E extends Error{constructor(){super("Encountered Promise during synchronous parse. Use .parseAsync() instead.")}}const Ae={};function P(e){return Ae}function Ee(e,r){return typeof r=="bigint"?r.toString():r}function Ze(e){const r=e.startsWith("^")?1:0,t=e.endsWith("$")?e.length-1:e.length;return e.slice(r,t)}const V=Symbol("evaluating");function g(e,r,t){let n;Object.defineProperty(e,r,{get(){if(n!==V)return n===void 0&&(n=V,n=t()),n},set(s){Object.defineProperty(e,r,{value:s})},configurable:!0})}const Y="captureStackTrace"in Error?Error.captureStackTrace:(...e)=>{};function G(e){return typeof e=="object"&&e!==null&&!Array.isArray(e)}function Oe(e){if(G(e)===!1)return!1;const r=e.constructor;if(r===void 0||typeof r!="function")return!0;const t=r.prototype;return!(G(t)===!1||Object.prototype.hasOwnProperty.call(t,"isPrototypeOf")===!1)}function Me(e,r,t){const n=new e._zod.constr(r??e._zod.def);return(!r||t?.parent)&&(n._zod.parent=e),n}function v(e){return{}}function j(e,r=0){if(e.aborted===!0)return!0;for(let t=r;t<e.issues.length;t++)if(e.issues[t]?.continue!==!0)return!0;return!1}function A(e,r){return r.map(t=>{var n;return(n=t).path??(n.path=[]),t.path.unshift(e),t})}function M(e){return typeof e=="string"?e:e?.message}function S(e,r,t){const n={...e,path:e.path??[]};if(!e.message){const s=M(e.inst?._zod.def?.error?.(e))??M(r?.error?.(e))??M(t.customError?.(e))??M(t.localeError?.(e))??"Invalid input";n.message=s}return delete n.inst,delete n.continue,r?.reportInput||delete n.input,n}const ee=(e,r)=>{e.name="$ZodError",Object.defineProperty(e,"_zod",{value:e._zod,enumerable:!1}),Object.defineProperty(e,"issues",{value:r,enumerable:!1}),e.message=JSON.stringify(r,Ee,2),Object.defineProperty(e,"toString",{value:()=>e.message,enumerable:!1})},Re=d("$ZodError",ee),N=d("$ZodError",ee,{Parent:Error}),Ne=e=>(r,t,n,s)=>{const o=n?Object.assign(n,{async:!1}):{async:!1},i=r._zod.run({value:t,issues:[]},o);if(i instanceof Promise)throw new E;if(i.issues.length){const u=new(s?.Err??e)(i.issues.map(c=>S(c,o,P())));throw Y(u,s?.callee),u}return i.value},Te=Ne(N),xe=e=>async(r,t,n,s)=>{const o=n?Object.assign(n,{async:!0}):{async:!0};let i=r._zod.run({value:t,issues:[]},o);if(i instanceof Promise&&(i=await i),i.issues.length){const u=new(s?.Err??e)(i.issues.map(c=>S(c,o,P())));throw Y(u,s?.callee),u}return i.value},Ce=xe(N),Be=e=>(r,t,n)=>{const s=n?{...n,async:!1}:{async:!1},o=r._zod.run({value:t,issues:[]},s);if(o instanceof Promise)throw new E;return o.issues.length?{success:!1,error:new(e??Re)(o.issues.map(i=>S(i,s,P())))}:{success:!0,data:o.value}},re=Be(N),Ie=e=>async(r,t,n)=>{const s=n?Object.assign(n,{async:!0}):{async:!0};let o=r._zod.run({value:t,issues:[]},s);return o instanceof Promise&&(o=await o),o.issues.length?{success:!1,error:new e(o.issues.map(i=>S(i,s,P())))}:{success:!0,data:o.value}},te=Ie(N),Le=e=>{const r=e?`[\\s\\S]{${e?.minimum??0},${e?.maximum??""}}`:"[\\s\\S]*";return new RegExp(`^${r}$`)},Ue=/^-?\d+(?:\.\d+)?/,De=/^(?:true|false)$/i,Ve=/^null$/i,Ge={major:4,minor:1,patch:13},b=d("$ZodType",(e,r)=>{var t;e??(e={}),e._zod.def=r,e._zod.bag=e._zod.bag||{},e._zod.version=Ge;const n=[...e._zod.def.checks??[]];e._zod.traits.has("$ZodCheck")&&n.unshift(e);for(const s of n)for(const o of s._zod.onattach)o(e);if(n.length===0)(t=e._zod).deferred??(t.deferred=[]),e._zod.deferred?.push(()=>{e._zod.run=e._zod.parse});else{const s=(i,u,c)=>{let a=j(i),l;for(const f of u){if(f._zod.def.when){if(!f._zod.def.when(i))continue}else if(a)continue;const p=i.issues.length,k=f._zod.check(i);if(k instanceof Promise&&c?.async===!1)throw new E;if(l||k instanceof Promise)l=(l??Promise.resolve()).then(async()=>{await k,i.issues.length!==p&&(a||(a=j(i,p)))});else{if(i.issues.length===p)continue;a||(a=j(i,p))}}return l?l.then(()=>i):i},o=(i,u,c)=>{if(j(i))return i.aborted=!0,i;const a=s(u,n,c);if(a instanceof Promise){if(c.async===!1)throw new E;return a.then(l=>e._zod.parse(l,c))}return e._zod.parse(a,c)};e._zod.run=(i,u)=>{if(u.skipChecks)return e._zod.parse(i,u);if(u.direction==="backward"){const a=e._zod.parse({value:i.value,issues:[]},{...u,skipChecks:!0});return a instanceof Promise?a.then(l=>o(l,i,u)):o(a,i,u)}const c=e._zod.parse(i,u);if(c instanceof Promise){if(u.async===!1)throw new E;return c.then(a=>s(a,n,u))}return s(c,n,u)}}e["~standard"]={validate:s=>{try{const o=re(e,s);return o.success?{value:o.data}:{issues:o.error?.issues}}catch{return te(e,s).then(i=>i.success?{value:i.data}:{issues:i.error?.issues})}},vendor:"zod",version:1}}),We=d("$ZodString",(e,r)=>{b.init(e,r),e._zod.pattern=[...e?._zod.bag?.patterns??[]].pop()??Le(e._zod.bag),e._zod.parse=(t,n)=>{if(r.coerce)try{t.value=String(t.value)}catch{}return typeof t.value=="string"||t.issues.push({expected:"string",code:"invalid_type",input:t.value,inst:e}),t}}),Fe=d("$ZodNumber",(e,r)=>{b.init(e,r),e._zod.pattern=e._zod.bag.pattern??Ue,e._zod.parse=(t,n)=>{if(r.coerce)try{t.value=Number(t.value)}catch{}const s=t.value;if(typeof s=="number"&&!Number.isNaN(s)&&Number.isFinite(s))return t;const o=typeof s=="number"?Number.isNaN(s)?"NaN":Number.isFinite(s)?void 0:"Infinity":void 0;return t.issues.push({expected:"number",code:"invalid_type",input:s,inst:e,...o?{received:o}:{}}),t}}),Ke=d("$ZodBoolean",(e,r)=>{b.init(e,r),e._zod.pattern=De,e._zod.parse=(t,n)=>{if(r.coerce)try{t.value=!!t.value}catch{}const s=t.value;return typeof s=="boolean"||t.issues.push({expected:"boolean",code:"invalid_type",input:s,inst:e}),t}}),qe=d("$ZodNull",(e,r)=>{b.init(e,r),e._zod.pattern=Ve,e._zod.values=new Set([null]),e._zod.parse=(t,n)=>{const s=t.value;return s===null||t.issues.push({expected:"null",code:"invalid_type",input:s,inst:e}),t}});function W(e,r,t){e.issues.length&&r.issues.push(...A(t,e.issues)),r.value[t]=e.value}const Je=d("$ZodArray",(e,r)=>{b.init(e,r),e._zod.parse=(t,n)=>{const s=t.value;if(!Array.isArray(s))return t.issues.push({expected:"array",code:"invalid_type",input:s,inst:e}),t;t.value=Array(s.length);const o=[];for(let i=0;i<s.length;i++){const u=s[i],c=r.element._zod.run({value:u,issues:[]},n);c instanceof Promise?o.push(c.then(a=>W(a,t,i))):W(c,t,i)}return o.length?Promise.all(o).then(()=>t):t}});function F(e,r,t,n){for(const o of e)if(o.issues.length===0)return r.value=o.value,r;const s=e.filter(o=>!j(o));return s.length===1?(r.value=s[0].value,s[0]):(r.issues.push({code:"invalid_union",input:r.value,inst:t,errors:e.map(o=>o.issues.map(i=>S(i,n,P())))}),r)}const Xe=d("$ZodUnion",(e,r)=>{b.init(e,r),g(e._zod,"optin",()=>r.options.some(s=>s._zod.optin==="optional")?"optional":void 0),g(e._zod,"optout",()=>r.options.some(s=>s._zod.optout==="optional")?"optional":void 0),g(e._zod,"values",()=>{if(r.options.every(s=>s._zod.values))return new Set(r.options.flatMap(s=>Array.from(s._zod.values)))}),g(e._zod,"pattern",()=>{if(r.options.every(s=>s._zod.pattern)){const s=r.options.map(o=>o._zod.pattern);return new RegExp(`^(${s.map(o=>Ze(o.source)).join("|")})$`)}});const t=r.options.length===1,n=r.options[0]._zod.run;e._zod.parse=(s,o)=>{if(t)return n(s,o);let i=!1;const u=[];for(const c of r.options){const a=c._zod.run({value:s.value,issues:[]},o);if(a instanceof Promise)u.push(a),i=!0;else{if(a.issues.length===0)return a;u.push(a)}}return i?Promise.all(u).then(c=>F(c,s,e,o)):F(u,s,e,o)}}),He=d("$ZodRecord",(e,r)=>{b.init(e,r),e._zod.parse=(t,n)=>{const s=t.value;if(!Oe(s))return t.issues.push({expected:"record",code:"invalid_type",input:s,inst:e}),t;const o=[],i=r.keyType._zod.values;if(i){t.value={};const u=new Set;for(const a of i)if(typeof a=="string"||typeof a=="number"||typeof a=="symbol"){u.add(typeof a=="number"?a.toString():a);const l=r.valueType._zod.run({value:s[a],issues:[]},n);l instanceof Promise?o.push(l.then(f=>{f.issues.length&&t.issues.push(...A(a,f.issues)),t.value[a]=f.value})):(l.issues.length&&t.issues.push(...A(a,l.issues)),t.value[a]=l.value)}let c;for(const a in s)u.has(a)||(c=c??[],c.push(a));c&&c.length>0&&t.issues.push({code:"unrecognized_keys",input:s,inst:e,keys:c})}else{t.value={};for(const u of Reflect.ownKeys(s)){if(u==="__proto__")continue;const c=r.keyType._zod.run({value:u,issues:[]},n);if(c instanceof Promise)throw new Error("Async schemas not supported in object keys currently");if(c.issues.length){t.issues.push({code:"invalid_key",origin:"record",issues:c.issues.map(l=>S(l,n,P())),input:u,path:[u],inst:e}),t.value[c.value]=c.value;continue}const a=r.valueType._zod.run({value:s[u],issues:[]},n);a instanceof Promise?o.push(a.then(l=>{l.issues.length&&t.issues.push(...A(u,l.issues)),t.value[c.value]=l.value})):(a.issues.length&&t.issues.push(...A(u,a.issues)),t.value[c.value]=a.value)}}return o.length?Promise.all(o).then(()=>t):t}}),Qe=d("$ZodLazy",(e,r)=>{b.init(e,r),g(e._zod,"innerType",()=>r.getter()),g(e._zod,"pattern",()=>e._zod.innerType?._zod?.pattern),g(e._zod,"propValues",()=>e._zod.innerType?._zod?.propValues),g(e._zod,"optin",()=>e._zod.innerType?._zod?.optin??void 0),g(e._zod,"optout",()=>e._zod.innerType?._zod?.optout??void 0),e._zod.parse=(t,n)=>e._zod.innerType._zod.run(t,n)});var K;class Ye{constructor(){this._map=new WeakMap,this._idmap=new Map}add(r,...t){const n=t[0];if(this._map.set(r,n),n&&typeof n=="object"&&"id"in n){if(this._idmap.has(n.id))throw new Error(`ID ${n.id} already exists in the registry`);this._idmap.set(n.id,r)}return this}clear(){return this._map=new WeakMap,this._idmap=new Map,this}remove(r){const t=this._map.get(r);return t&&typeof t=="object"&&"id"in t&&this._idmap.delete(t.id),this._map.delete(r),this}get(r){const t=r._zod.parent;if(t){const n={...this.get(t)??{}};delete n.id;const s={...n,...this._map.get(r)};return Object.keys(s).length?s:void 0}return this._map.get(r)}has(r){return this._map.has(r)}}function er(){return new Ye}(K=globalThis).__zod_globalRegistry??(K.__zod_globalRegistry=er());function rr(e,r){return new e({type:"string",...v()})}function tr(e,r){return new e({type:"number",checks:[],...v()})}function nr(e,r){return new e({type:"boolean",...v()})}function sr(e,r){return new e({type:"null",...v()})}const _=d("ZodMiniType",(e,r)=>{if(!e._zod)throw new Error("Uninitialized schema in ZodMiniType.");b.init(e,r),e.def=r,e.type=r.type,e.parse=(t,n)=>Te(e,t,n,{callee:e.parse}),e.safeParse=(t,n)=>re(e,t,n),e.parseAsync=async(t,n)=>Ce(e,t,n,{callee:e.parseAsync}),e.safeParseAsync=async(t,n)=>te(e,t,n),e.check=(...t)=>e.clone({...r,checks:[...r.checks??[],...t.map(n=>typeof n=="function"?{_zod:{check:n,def:{check:"custom"},onattach:[]}}:n)]}),e.clone=(t,n)=>Me(e,t,n),e.brand=()=>e,e.register=((t,n)=>(t.add(e,n),e))}),or=d("ZodMiniString",(e,r)=>{We.init(e,r),_.init(e,r)});function I(e){return rr(or)}const ir=d("ZodMiniNumber",(e,r)=>{Fe.init(e,r),_.init(e,r)});function ur(e){return tr(ir)}const ar=d("ZodMiniBoolean",(e,r)=>{Ke.init(e,r),_.init(e,r)});function cr(e){return nr(ar)}const lr=d("ZodMiniNull",(e,r)=>{qe.init(e,r),_.init(e,r)});function fr(e){return sr(lr)}const dr=d("ZodMiniArray",(e,r)=>{Je.init(e,r),_.init(e,r)});function hr(e,r){return new dr({type:"array",element:e,...v()})}const pr=d("ZodMiniUnion",(e,r)=>{Xe.init(e,r),_.init(e,r)});function ne(e,r){return new pr({type:"union",options:e,...v()})}const mr=d("ZodMiniRecord",(e,r)=>{He.init(e,r),_.init(e,r)});function se(e,r,t){return new mr({type:"record",keyType:e,valueType:r,...v()})}const gr=d("ZodMiniLazy",(e,r)=>{Qe.init(e,r),_.init(e,r)});function br(e){return new gr({type:"lazy",getter:e})}const _r=ne([I(),ur(),cr(),fr()]),B=br(()=>ne([_r,hr(B),se(I(),B)]));se(I(),B);export{Or as O,$r as a,Pr as b,Mr as c,zr as d,Sr as e,kr as f,Ar as g,Rr as h,jr as i,wr as j,B as k,be as n,z as o,Er as s,Zr as u};
